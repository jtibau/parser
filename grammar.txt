Grammar for CS5314 Prolog Assignment Spring 2016

The following grammar is close to the Warren grammar for expressions
with a few additions of datatypes,as operations and type
declarations. Note that the only executable statements in this grammar
are assignment and compound if statements.

We also assume that <integer> is a sequence of numeric digits and that
<numWDecimal> is a sequence of digits containing a period (i.e., a
float literal). Assume <name> is a sequence of letters and numbers
beginning with a letter.  Assume that string literals consist of
double quotes (") surrounding a sequence of characters.  There are no
bool literals.

The syntax below  defines the structure of valid statements in the
programming language; we also need to define type rules for this
language. Basically, copy assignments are possible between two
variables of compatible type; similarly, a literal scalar value can be
assigned to a variable of compatible type.  For scalar variables, a
type coercion occurs between types when no loss of precision will
result.  For example, if X is type float and Y is type int, then X=Y
is type correct because an int value can be coerced into a float
value without losing any precision; however, Y=X is illegal because a
float value cannot be changed into an int value without possibly
losing precision.  There is no coercion between a numerical type and
string, or a numerical type and bool.  The length of a string literal
is NOT considered part of its type.

For aggregate variables there are no literal values, however there
are copy assignment statements.  These assignments can only occur
between variables of compatible type.  The arity and length of an
array are considered part of the type.  This means if we declare A to
be of type int[10] and B to be of type int[5][2] then although these
two arrays have the same number of elements, they have different arity
(e.g., A is 1 dimensional and B is 2 dimensional) and therefore the
assignments A=B and B=A cannot be correctly typed. If we declare C to
be type int[10] and D to be type int[15], then the following
assignments are correct: A=C or C=A, while the assignments A=D or D=A
are type errors.  Thus, we are using a form of structural 
type equivalence for arrays.

For structs, this language uses a form of structural equivalence,
because we consider the struct field names to be part of the struct
type (like the type constructors).  This means that the fields of a
struct can appear in arbitrary order in a struct definition, but the
type of that struct is unchanged.  Note this is DIFFERENT than in C!!!
(Note: we are NOT allowing recursive struct types in our language.)

A comment in this language starts with /* and ends with */.

GRAMMAR:

Type declaration statements:
<type-decl> --> <type> <name-list> 
<name-list> --> <name> | <name>, <name-list> 
<type> --> <simple-type> | <array-type>  | <struct-type>
<simple-type> --> int | float | string | bool
<array-type> --> <type> [ <integer> ]
<struct-type> --> struct { <field-list>}
<field-list> -->  <type> <name> ; |  <type> <name> ; <field-list>

(Notice that structs can contain array fields and arrays can contain
structs as elements.)

Program (mostly from Warren paper):
<program> --> <type-decl-stmts> ; <stmts>   
<type-decl-stmts> --> <type-decl> | <type-decl-stmts> ; <type-decl>
<stmts> --> <stmt> | <stmts> ; <stmt>
<stmt> --> <assignStmt> | <ifStmt>
<assignStmt> -->  <id> = <expr>
<id> --> <name> |  <id>.<name> | <id> [ <expr> ]

(The middle alternative is field selection; the <id> is a struct
variable name which has a field named <name>.  Note f.a.c is generated
by this rule, where  f is a struct, a is a field of f which is a struct,
and c is a field of a. The last alternative is an array element for which 
the <expr> must be of type int. For example, f.a.b[2] can be generated by 
these rules with f a struct, a a field of f that is itself a struct,
b a field of a that is an array and b[2] an array element.)

<ifStmt> --> if <test> then <stmt> else <stmt> 
<test> --> <expr> <compareOp> <expr> | <name>
(The test in an if statement must be of type bool.)

<expr> --> <expr> <op1> <expr1> | <expr1>
<expr1> --> <expr1> <op2> <expr0> | <expr0>
<expr0> --> <id> | <integer> | <numWDecimal> | <stringLiteral> | (<expr>) 
****NEXT RULE HAS BEEN REVISED 2/17/16******
<comparOp> --> == | < | > | <= | >= | <> (not equal)

(The scalar types can be compared with all operators; the aggregate types 
can only be compared by == or != which means an element by element comparison
for arrays and a named field value by  field value comparison for structs.)

******2/17/16** RULES FOR op1 and op2 have been changed to reflect usual operator precedence*****
<op2> --> * | /
(These two operators can only be used on scalar numerical types.)

<op1> --> + | -
(- is only used on scalar numerical types but + is overloaded and can
be used for scalar numerical types or for 2 string operands.)
<string-op> --> + (concatenation)


